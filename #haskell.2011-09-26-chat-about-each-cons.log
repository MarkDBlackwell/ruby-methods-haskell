[wrong date & time: 2011-09-27 00:58:56] [INFO] Now logging to <file:///C:/Documents%20and%20Settings/Mark/Application%20Data/Mozilla/SeaMonkey/Profiles/vcfjbkpz.default/chatzilla/logs/freenode/channels/%23haskell.2011-09-27.log>.

The below was pasted from a log on the web at http://tunes.org/~nef/logs/haskell/11.09.26  ended at 1:00 AM, my time.

18:37:47 <MarkDBlackwell> Please forgive my newbishness; I'm considering porting some Ruby methods to Haskell. I've already done Enumerable#each_cons (for 'each consecutive'), which, from a list, makes a list of short lists: e.g., eachCons 4 [1,2,3,4,5,6] would be [[1,2,3,4],[2,3,4,5],[3,4,5,6]]. It was useful in solving Euler's problem number eight: given a huge number, find the five consecutive digits with the...
18:37:49 <MarkDBlackwell> ...greatest product. Am I right that there isn't such a function in Haskell, already?
18:38:46 <DanBurton> stop...Hoogle time
18:39:00 <DanBurton> @hoogle Int -> [a] -> [[a]]
18:39:01 <dobblego> can't Hoogle this
18:39:01 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
18:39:01 <lambdabot> Prelude drop :: Int -> [a] -> [a]
18:39:01 <lambdabot> Prelude take :: Int -> [a] -> [a]
18:39:11 <dobblego> Data.List.Split by the way
18:39:58 <geheimdienst> > map (take 4) $ tails [1..6]
18:39:59 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6],[5,6],[6],[]]
18:40:09 <geheimdienst> MarkDBlackwell: you might be interested in that ^^
18:40:25 <shachaf> MarkDBlackwell: There isn't one built-in, but you can do something geheimdienst-style.
18:40:46 <shachaf> However, that'll give you those last n elements, which you probably don't want.
18:40:55 <geheimdienst> filter it for only lists of length 4 and you're good to go. i used only the most basic functions (= Prelude functions)
18:41:11 <DanBurton> > map (take 4) $ filter (\xs -> length xs == 4) tails [1..6]
18:41:11 <shachaf> geheimdienst: :-(length)
18:41:12 <lambdabot>   Couldn't match expected type `[[a]]'
18:41:12 <lambdabot>         against inferred type `[a1] ->...
18:41:20 <DanBurton> > map (take 4) $ filter (\xs -> length xs == 4) $ tails [1..6]
18:41:21 <lambdabot>   [[3,4,5,6]]
18:41:31 <DanBurton> waitaminute
18:41:38 <DanBurton> let me try that again
18:41:50 <DanBurton> > filter (\xs -> length xs == 4) $ map (take 4) $ tails [1..6]
18:41:51 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:42:00 <DanBurton> filter after map, derp
18:42:09 <ski> hm .. `forall as,n. length as = n => length (eachCons 0 as) = n+1'
18:42:42 <geheimdienst> shachaf: u no likes a length? wat wuld u make insted??
18:42:59 <BMeph> Actually, since it starts there, takeWhile might be a better choice than filter. :)
18:43:14 <DanBurton> I was thinking that too
18:43:29 <ski> hm, some kind of list subtraction thingie might be handy
18:43:46 <DanBurton> @src (//)
18:43:46 <lambdabot> arr@(Array l u _) // ies = unsafeReplace arr [(index (l,u) i, e) | (i, e) <- ies]
18:43:50 <BMeph> > takeWhile (not . null . drop 3) . map (take 4) $ tails [1..6]
18:43:52 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:44:55 <donri> tails?
18:44:59 <shachaf> BMeph++
18:45:03 <shachaf> Not as if it matters, of course.
18:45:25 <geheimdienst> i think the (not . null . drop 3) thing is kinda roundabout ...
18:45:55 <shachaf> @let notNullDrop n = not . null . drop n
18:45:56 <lambdabot>  Defined.
18:46:03 * shachaf takes a bow.
18:46:13 <Cale> > ap (zipWith const) (drop 4) . map (take 4) . tails $ [1..6]
18:46:15 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:46:31 <DanBurton> let foo n xs = take (length xs - n + 1) . map (take n) . tails xs
18:46:31 <Cale> kekeke
18:46:32 <BMeph> @let unTake n = not . null . drop (pred n)
18:46:33 <lambdabot>  Defined.
18:46:37 <DanBurton> @let foo n xs = take (length xs - n + 1) . map (take n) . tails xs
18:46:39 <lambdabot>  Defined.
18:46:46 <DanBurton> > foo [1..6] 4
18:46:47 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:46:48 <lambdabot>         against inferred type ...
18:46:53 <DanBurton> doh
18:46:55 <BMeph> That way, you can use the same 'n' for that, and the take in the map. ;)
18:46:58 <ski> @src tails
18:46:59 <lambdabot> tails []         = [[]]
18:46:59 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:47:02 <ski> donri ^
18:47:04 <Cale> > (zipWith const <*> drop 4) . map (take 4) . tails $ [1..6]
18:47:06 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:47:08 --- join: luqui (~luqui@c-67-176-93-108.hsd1.co.comcast.net) joined #haskell
18:47:09 <Cale> > (zipWith const <*> drop 4) . map (take 4) . tails $ [1..10]
18:47:11 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6],[4,5,6,7],[5,6,7,8],[6,7,8,9],[7,8,9,10]]
18:47:23 <ski> > tails "abcd"
18:47:24 <lambdabot>   ["abcd","bcd","cd","d",""]
18:47:26 <DanBurton> > foo 4 [1..6]
18:47:27 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
18:47:27 <lambdabot>    arising from a use...
18:47:30 <donri> ski: i don't have it, new since something?
18:47:38 <DanBurton> :t foo
18:47:39 <Cale> Computing lengths is admitting defeat
18:47:39 <geheimdienst> cale: can you pull the 4 out? pointless plz
18:47:40 <lambdabot> forall a. Int -> [[a]] -> [[[a]]]
18:47:40 <geheimdienst> ;)
18:47:43 <luqui> :t foo
18:47:44 <lambdabot> forall a. Int -> [[a]] -> [[[a]]]
18:47:57 <Cale> I guess I could...
18:48:06 <Cale> But it'd make it ugly
18:48:10 <BMeph> Cale: Computing a length you don't care about is admitting defeat. ;)
18:48:17 <luqui> foo 2 [[1,2,3],[4,5,6]]
18:48:18 <geheimdienst> cale: i was kidding
18:48:20 <luqui> > foo 2 [[1,2,3],[4,5,6]]
18:48:21 <lambdabot>   [[[1,2]],[[4,5]],[]]
18:48:22 <DanBurton> @let foo n xs = take (length xs - n + 1) . map (take n) . tails $ xs
18:48:23 <lambdabot>  <local>:12:0:
18:48:23 <lambdabot>      Warning: Pattern match(es) are overlapped
18:48:23 <lambdabot>               I...
18:48:30 <ski> > (map (tail . inits) . tails) "abcd"
18:48:32 <lambdabot>   [["a","ab","abc","abcd"],["b","bc","bcd"],["c","cd"],["d"],[]]
18:48:38 <ski> @index tails
18:48:38 <lambdabot> Data.List
18:48:42 <ski> donri ^
18:48:44 <DanBurton> you guys mind if I undefine?
18:48:58 <donri> oh so the "only prelude" was a lie :)
18:49:06 <DanBurton> @let foo2 n xs = take (length xs - n + 1) . map (take n) . tails $ xs
18:49:07 <lambdabot>  Defined.
18:49:20 <DanBurton> > foo2 4 [1..6]
18:49:22 <lambdabot>   [[1,2,3,4],[2,3,4,5],[3,4,5,6]]
18:50:11 <ski> @remember Cale Computing lengths is admitting defeat
18:50:12 <lambdabot> It is forever etched in my memory.
18:50:31 <DanBurton> @pl let foo3 n xs = take (lengt xs - n + 1) . map (take n) . tails $ xs in foo3
18:50:32 <lambdabot> join . ap (flip . (((.) . take) .) . flip flip 1 . ((+) .) . flip ((-) . lengt)) ((. tails) . map . take)
18:50:56 <DanBurton> @pl let foo3 n xs = take (length xs - n + 1) . map (take n) . tails $ xs in foo3
18:50:56 <lambdabot> join . ap (flip . (((.) . take) .) . flip flip 1 . ((+) .) . flip ((-) . length)) ((. tails) . map . take)
18:51:03 <DanBurton> missed the h in length xP
18:51:17 <luqui> woah
18:51:20 <luqui> flip flip 1
18:51:27 <luqui> :t flip flip 1
18:51:28 <lambdabot> forall (f :: * -> *) a b. (Functor f, Num a) => f (a -> b) -> f b
18:51:48 <DanBurton> back to flip flip are we? xD
18:51:53 <DanBurton> :t flipflip
18:51:55 <lambdabot> forall t t1 t2. t -> (t1 -> t -> t2) -> t1 -> t2
18:52:06 <DanBurton> @src flipflip
18:52:06 <lambdabot> Source not found. You type like i drive.
18:52:11 <luqui> :t flip flip
18:52:12 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
18:52:19 <DanBurton> aw forgot how I defined it
18:52:22 <luqui> oh something funny about this flip
18:52:23 <luqui> :t flip
18:52:23 <ski> @type Prelude.flip Prelude.flip 1
18:52:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
18:52:24 <lambdabot> forall a b c. (Num b) => (a -> b -> c) -> a -> c
18:52:37 <donri> it's shit like this, haskell
18:52:55 <Cale> kekeke
18:52:56 <ski> luqui : what !?, it's a straight-forward generalization
18:53:07 <luqui> yes, it is
18:53:10 <luqui> i just wasn't expecting it
18:53:20 * ski coughs
18:53:30 <luqui> and flip is a pretty terrible name
18:53:34 <luqui> for this new thing
18:53:44 <ski> would `transpose' be better ?
18:53:51 <donri> flipflop
18:53:57 <DanBurton> wibblewobble
18:54:07 <ski> (<http://www.funmath.be/> calls it "transposition")
18:54:13 <donri> one art please
18:55:00 <luqui> ooh funmath looks... fun
18:55:22 * ski . o O ( <http://remix.kwed.org/download.php/2047/Lagerfeldt%20-%20Flip%20the%20Flop%20%28Rock%20My%20Commodore%29.mp3> )
19:03:25 <MarkDBlackwell> Thanks, DanBurton (and others)! In Prelude, your foo2 worked well for me:   foo2 n xs = take (length xs - n + 1) . map (take n) . tails $ xs     . So, I'm thinking of doing a module with all the Ruby methods, wouldn't that invite Ruby programmers more? (In addition to making a lot of unidiomatic  Haskell code, of course.)
19:03:40 <blackdog> MarkDBlackwell: i reckon a cheat sheet would be better.
19:03:50 <luqui> blackdog++
19:04:02 <DanBurton> MarkDBlackwell: I think a module wouldn't hurt though
19:04:15 <DanBurton> the docs could serve as a cheat sheet
19:04:43 <DanBurton> MarkDBlackwell: what exactly are the ruby methods that you wish were in Prelude?
19:05:15 <MarkDBlackwell> blackdog, thanks; a cheat sheet -- better and easier!
19:05:28 <blackdog> the split
19:05:39 <blackdog> urk. the split stuff is the worst - i think most rubyists expect it to be included
19:05:55 <johnFreeman> blackdog: Java has a split method in the String class
19:05:55 <blackdog> where instead we have a couple of funny specialised versions like words and lines
19:06:03 <MarkDBlackwell> All of them, for Rubyist comfort, is the idea. :)
19:06:27 <MarkDBlackwell> (DanBurton)
19:06:28 <blackdog> MarkDBlackwell: i take it you're a rubyist getting your feet wet in FP?:)
19:06:49 <blackdog> i've been trying to get the rubyists in for ages. we need more web types.
19:06:52 <blackdog> functional programming
19:07:01 * incluye is a former rubyist
19:07:28 <DanBurton> blackdog: plenty of rubyists are aready into FP; ruby blocks are just a handy syntax for higher order functions
19:07:42 <MarkDBlackwell> blackdog, Feet wet, yes, just starting; finished through the modules chapter in _Learn You a Haskell For Great Good_. :)
19:08:08 <DanBurton> I love LYAH. So much. It's what started me on Haskell, too.
19:08:32 <MarkDBlackwell> blackdog, a Rubyist, yes, previously Java, C++, Fortran; Algolish. Love functional-style programming in Ruby. :)
19:08:37 <blackdog> DanBurton: Functional means that the primary method of composition is through functions rather than mutable references, not just that you can pass closures around
19:08:43 <kmc> DanBurton, they're not *just* that; they also have properties resembling first-class continuations
19:09:11 <blackdog> johnFreeman: ruby's a lovely little language for certain things. i'd certainly rather use it than java.
19:09:23 <kmc> this channel can argue about what the word "functional" means for hours on end
19:09:45 <DanBurton> Let's do it! >.>
19:10:02 <kmc> generally there's one camp that argues that "functional" should only be applied to languages exactly like Haskell in every way
19:10:18 <MarkDBlackwell> blackdog, thanks, single-assignment, lazy evaluation, functional, very appealing personally. :)
19:10:19 <kmc> and another which takes it as a general term including almost every modern language
19:10:28 <kmc> and another that basically accepts whatever wikipedia / their textbook says
19:11:01 <DanBurton> the cool thing about Haskell is its type system restrictions. Which is weird because normally you'd think that restrictions would be annoying
19:11:21 <kmc> it's restricting me from writing incorrect code
19:11:41 <MarkDBlackwell> I love it -- and people say it was inspired by _why_the_lucky_stiff's Ruby book -- any information on whether that's true?
19:11:44 <companion_cube> or itertools
19:11:49 <MarkDBlackwell> (DanBurton)
19:12:22 <DanBurton> MarkDBlackwell: you mean regarding  LYAH? Not sure; sounds kinda true though.
19:13:48 <MarkDBlackwell> DanBurton, yes, LYAH.
19:14:33 <kmc> DanBurton, a lot of it is that Haskell and GHC have features for making unusually composable code: declarative programming, equational reasoning, laziness, pattern-matching, sharing, EDSLs, first-class IO, first-class concurrency, STM, pure parallelism
19:15:48 <MarkDBlackwell> DanBurton: I mean I like Ruby's functional part of all the methods like map that do whole collections.
19:16:54 <MarkDBlackwell> kmc, composable functions; Ruby, too.
19:20:14 <MarkDBlackwell> kmc, the restrictions are empowering, strangely
19:27:10 <kmc> the key difference is that Haskell lets you build expressions out of statements, while most languages only directly support statements built out of expressions
19:27:14 <DanBurton> applicative are my favorite kind of functors
19:54:23 <MarkDBlackwell> DanBurton, I thought my solution wouldn't work for infinite lists, but it does!   eachCons :: [a] -> Int -> [[a]]
19:54:24 <MarkDBlackwell>   eachCons x n
19:54:26 <MarkDBlackwell>     | n <= 0 = [[]]
19:54:28 <MarkDBlackwell>     | otherwise = consecutives
19:54:29 <MarkDBlackwell>     where
19:54:31 <MarkDBlackwell>       sequences = map (`drop` x) [0..(n-1)]
19:54:33 <MarkDBlackwell>       consecutives = [y | y <- transpose sequences, n==length y]
19:54:39 <companion_cube> MarkDBlackwell: pastebin.
19:54:57 <DanBurton> MarkDBlackwell: cool sauce, congrats
19:55:21 <hpaste> MarkDBlackwell pasted “eachCons” at http://hpaste.org/51819
19:55:53 * ski would set `eachCons x n | n < 0 = error ("eachCons _ " ++ showsPrec 11 n "")'
19:56:11 <MarkDBlackwell> DanBurton, thank you; that was my original solution -- I might adopt yours. :)
19:56:41 <DanBurton> MarkDBlackwell: but my version wouldn't work on infinite lists since it checks the length of the input list, which is infinite
19:56:57 * ski idly wonders why MarkDBlackwell swapped the arguments of `eachCons'
19:57:09 <JoeyA> @hoogle eachCons
19:57:09 <lambdabot> No results found
19:57:32 <JoeyA> @djinn [a] -> Int -> [[a]]
19:57:32 <lambdabot> Error: Undefined type []
19:57:44 <JoeyA> @djinn m a -> Int -> m (m a)
19:57:44 <lambdabot> Error: Undefined type Int
19:57:45 * DanBurton wonders what order ski is referencing
19:58:18 <luqui> JoeyA, or any of the context variables' context variables
19:58:48 <DanBurton> is there a reason djinn doesn't recognize the [] type?
19:58:57 <luqui> yeah
19:59:04 <luqui> the solver doesn't understand recursive types
19:59:22 <MarkDBlackwell> ski, for Rubyists' comfort, to matching the original Ruby:  [1,2,3,4,5].each_cons(3).to_a  gives [[1, 2, 3], [2, 3, 4], [3, 4, 5]] .
20:00:16 <DanBurton> so Ruby has each_cons built into it?
20:01:18 <JoeyA> Right, that's why most GHC wouldn't be able to support it, practically speaking.
20:01:20 <MarkDBlackwell> DanBurton, yes: Enumerable#each_cons  ,  see http://www.ruby-doc.org/core/classes/Enumerable.html#M001515
20:01:30 * DanBurton just tried that out on tryruby.org :)
20:01:58 <DanBurton> Ruby's got some cool stuff
20:02:52 <MarkDBlackwell> DanBurton, yes, powerful composable methods, so thinking of making a Haskell module for the few left out.
20:03:43 <ski> MarkDBlackwell : but what does `[1,2,3,4,5].each_cons(0).to_a' give ?
20:04:06 <JoeyA> @let eachCons n = takeWhile ((== n) . length) . map (take n) . tails
20:04:07 <lambdabot>  Defined.
20:04:15 <luqui> ski, argument error
20:04:17 <JoeyA> > eachCons 3 [1..]
20:04:19 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
20:04:25 <JoeyA> > eachCons 3 [1..5]
20:04:25 <ski> MarkDBlackwell : originally you talked about `eachCons 4 [1,2,3,4,5,6]', not `eachCons [1,2,3,4,5,6] 4'
20:04:27 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
20:04:30 <MarkDBlackwell> ski, I suppose this is what I'm learning, that it's good to use the Haskell usual order of eachCons x n  because the list in Ruby was left of the method name, anyway. Probably good to go with eachCons x n .
20:04:39 <ski> luqui : bad Ruby !
20:04:40 <luqui> those practical languages never get the corner cases right
20:05:16 <JoeyA> > eachCons 0 [1..]
20:05:18 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
20:05:36 <MarkDBlackwell> ski, Ah, I made it up, more Haskell-like at first on chat -- now I see what you mean -- sorry about that!
20:05:43 <DanBurton> ski: in ruby it produces an "invalid argument error"
20:05:47 <ski> MarkDBlackwell : i would probably prefer having the count argument before the list argument -- it appears that partially applying on the count would be more common that partially applying on the list
20:05:56 <DanBurton> ski: actually, "ArgumentError: invalid size"
20:05:58 <JoeyA> > eachCons 0 [1..10]
20:06:00 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[]]
20:06:16 <ski> DanBurton : it ought to give `[[],[],[],[],[],[],[]]' ..
20:06:38 <DanBurton> ski: because that's what the Haskell version does?
20:07:01 <DanBurton> an error makes more sense to me
20:07:19 <MarkDBlackwell> I tested it originally, and now, too:  [].each_cons(1).to_a returns an empty list, no error.
20:07:58 <MarkDBlackwell> DanBurton, I suppose each consecutive 'no elements' doesn't make much sense.
20:08:55 <DanBurton> > repeat []
20:08:56 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
20:09:07 <ski> > map (eachCons 3) (words "frobnicate the veeblefitzer")  -- partially applying on the counnt
20:09:09 <lambdabot>   [["fro","rob","obn","bni","nic","ica","cat","ate"],["the"],["vee","eeb","eb...
20:09:12 <DanBurton> seems to me that is what it should produce for an input of 0
20:09:18 <MarkDBlackwell> ski, I see, an infinite list of empty lists! Well, in Ruby, if I convert to an array, they don't infinite lists.
20:09:22 * ski can't counnt
20:10:04 <donri> python: [x[i:i+size] for i in range(len(x)-size+1)]
20:10:07 <ski> MarkDBlackwell : no, `l.each_cons(n).to_a' ought to give a list of length `n+1', that should be entirely feasible in Ruby
20:10:34 <ski> (a list of length `n+1' with each element being the empty list, i.e.)
20:11:15 <DanBurton> ski: disagree; it should be an infinite list, not a list of length n+1. In my mind it's like it starts at the beginning and then takes 0 elements. Then it's still at the beginning and takes 0 elements agian.
20:11:30 <DanBurton> and again and again
20:11:33 <DanBurton> like an iterator
20:11:43 <ski> MarkDBlackwell : er, sorry, i'm goofing that up -- i *meant* `l.each_cons(0).to_a' where `l' is a list of *length* `n'
20:11:48 <ski> (sorry, i haven't slept)
20:12:01 <DanBurton> no wait that's wrong jk
20:12:07 <DanBurton> ignore what I just said
20:12:34 <DanBurton> it just clicked in my brain
20:13:22 <DanBurton> in any event, if you're using each_cons(0) you're probably doing it wrong anyways. Why not just `map const []` ?
20:13:33 <DanBurton> and prepend []
20:13:45 * ski . o O ( <http://sv.wikipedia.org/wiki/Lidnersk_kn%E4pp> )
20:14:03 <ski> DanBurton : consistency
20:14:24 <MarkDBlackwell> DanBurton, Ruby has some lazy evaluation libraries which work with Enumerators, one of which is returned by the bare [1,2,3].each_cons(1) . They can be infinite: http://www.ruby-doc.org/core/classes/Enumerator.html
20:14:46 <ski> if there's no good reason to exclude the trivial cases, they ought to be included (such that they extrapolate correctly from the other cases)
20:14:49 <DanBurton> ski: well let's email the Ruby devs and tell them their each_cons is inconsistent
20:15:17 * ski is opposed to unfair discrimination against zero and friends
20:15:24 <luqui> getting the "useless" corner cases of a function right means that you don't have to do as much work to get the corner cases of functions using that function right
20:15:34 <luqui> and those corner cases might be useful for various things
20:15:39 <luqui> usually the correctness of a recursive definition
20:15:41 * DanBurton discriminates against negatives
20:16:29 * ski takes the inverse of discriminants
20:16:50 <DanBurton> so wait if you do each_cons(-2) should that take the two elements directly *before* each position in the list?
20:17:14 <DanBurton> in that case our Haskell definition fails
20:17:16 <MarkDBlackwell> ski, very funny; it's because of the problem of usually having no infinite lists in Ruby, that they reject taking elements 0 at a time. ;/
20:17:39 <ski> MarkDBlackwell : again, infinite lists are unrelated to this issue
20:18:11 <luqui> DanBurton, yeah i think that is a reasonable extension
20:18:25 * luqui does his daily lament that there is no Nat type in haskell
20:18:31 <MarkDBlackwell> ski, an infinite-list version could be written in Ruby, but I think the Rubyists will be happy with a Haskell port that extends it a little bit.
20:18:45 <DanBurton> let negativeFriendlyEachCons n xs | n < 0 = same as eachCons but using `heads` instead of `tails` ?
20:18:52 <ski> in case `l' has `n' elements, then `l.each_cons(k).to_a' will have `n+1-k' elements
20:18:59 <luqui> DanBurton, you mean inits?
20:19:08 <ski> so if `k' is `0', it should have `n+1' elements, to complete the pattern
20:19:32 <DanBurton> luqui: yeah I guess. My brain said "what's the opposite of tails" and the answer seemed to obviously be "heads" ;)
20:19:34 <ski> MarkDBlackwell ^
20:20:12 <MarkDBlackwell> ski, well, I mean [1,2,3].each_cons(0).to_a is rejected due to it probably producing an infinite length. If you want to say Ruby is wrong, I agree with you. :)
20:20:37 <ski> DanBurton : i'd first try to find a law that relates `eachCons (n0 + n1)' to `eachCons n0' and `eachCons n1'
20:20:57 <luqui> MarkDBlackwell, each_cons(0) should not produce an infinite length list
20:21:01 <luqui> I think that's what we're getting at
20:21:35 <ski> DanBurton : then `eachCons (-n)' (for negative `-n') should be such that it together with `eachCons n' (which is a known case) is related to `eachCons 0' (also a known case)
20:22:20 <MarkDBlackwell> ski, so you would only ever get two lists back -- haha -- why do I get the feeling you are kidding?
20:22:56 <ski> MarkDBlackwell : to be fully clear, i'm not claiming `[1,2,3].each_cons(0).to_a' ought to give an infinite list. i'm claiming it ought to give a list of four elements (each an empty list)
20:23:34 <ski> > eachCons 3 [0,1,2]
20:23:36 <lambdabot>   [[0,1,2]]
20:23:37 <ski> > eachCons 2 [0,1,2]
20:23:39 <lambdabot>   [[0,1],[1,2]]
20:23:40 <ski> > eachCons 1 [0,1,2]
20:23:41 <lambdabot>   [[0],[1],[2]]
20:23:43 <ski> > eachCons 0 [0,1,2]
20:23:45 <lambdabot>   [[],[],[],[]]
20:23:49 <MarkDBlackwell> ski, what is (^)?  please
20:23:50 <ski> see the pattern ?
20:24:19 <MarkDBlackwell> DanBurton, each consecutive negative number of elements should produce something imaginary, I would think.
20:25:15 <MarkDBlackwell> ski, well, each consecutive helps in Euler problem eight, which is to find five consecutive digits in a large number with the greatest product. It's a useful method.
20:25:39 <luqui> MarkDBlackwell, produce lists of negative length, perhaps
20:26:03 <luqui> we're not taking roots so i don't know where the imaginary bit comes in :-)
20:26:17 * ski thinks finding digits in decimal numerals is a bit silly
20:26:52 * ski played around one time with "diff-lists of negative length"
20:28:15 <ski> > ((\('a' : 'b' : 'c' : s) -> s) . (\s -> 'a' : 'b' : 'c' : s)) ""  -- a la this
20:28:17 <lambdabot>   ""
20:29:00 <MarkDBlackwell> ski, that's interesting about the pattern. Hm...
20:30:33 <MarkDBlackwell> luqui, yes, just being poetic. Yes, I know, Haskell has some powerful mathematics people, more mathematical than I, if I can be forgiven under the 'big tent' of Haskell. :)
20:30:53 <DanBurton> ski I think you missed the real question about ^
20:30:59 <luqui> it was actually a pun, i didn't figure you meant imaginary as in sqrt(-1)
20:31:57 <DanBurton> MarkDBlackwell: if I say something but forget to prefix it with someone's name, then I write "YourName ^" in a later comment. The ^ is simply to direct your attention upwards to my prevoius comment
20:33:27 <MarkDBlackwell> ski, back a few lines, after you said, 'so if `k' is `0', it should have..., you said to me, MarkDBlackwell ^  -- I suppose you were pointing to that comment, and saying, 'look up', it is for me! :D
20:35:00 <MarkDBlackwell> DanBurton, thanks, I understand about ^ now. :)
20:35:50 <DanBurton> MarkDBlackwell: good :)
20:40:55 <ski> MarkDBlackwell : oh, so i apparently did
20:41:11 <ski> when you wrote `(^)', i was thinking about the haskell operations
20:44:22 <MarkDBlackwell> luqui, well, yes, I was intuitively thinking it would be an imaginary number, for some reason I hadn't worked out, yet. Perhaps the result should contain a negative number of lists, which when multiplied by the negative size of each, would constitute the original list. Then, if the sublist length is chosen to be about the square root of the original list length, it works: positive or...
20:44:23 <MarkDBlackwell> ...negative. That's still not imaginary, unless I joke that the original list had a negative length. Well, let's say that it does, for some backward list. Then each consecutive sublist could have an imaginary length and there be an imaginary number of them. I uphold the equivalence of positive and negative length lists, after all! <jokingly>
20:44:55 <luqui> %-)
20:47:23 <MarkDBlackwell> ski, that's good, no problem.
20:48:17 <MarkDBlackwell> Everyone, this is indeed a friendly channel of people, as advertised! Thanks again
20:49:22 <MarkDBlackwell> bye
20:49:32 <ski> MarkDBlackwell : welcome back soon !
20:49:48 <MarkDBlackwell> ski, thank you, very much. :)
20:49:58 --- part: MarkDBlackwell left #haskell
